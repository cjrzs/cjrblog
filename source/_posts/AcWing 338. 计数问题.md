---
title: AcWing 338. 计数问题
math: true
date: 2022-02-11
comment: true
tags:
- AcWing算法基础课
- 计数型动态规划
categories:
- 算法
- 动态规划
--- 

# [AcWing 338. 计数问题](https://www.acwing.com/problem/content/340/)
> 给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0∼9 的出现次数。
> 
> 例如，a=1024，b=1032，则 a 和 b 之间共有 9 个数如下：
> 
> 1024 1025 1026 1027 1028 1029 1030 1031 1032
> 
> 其中 0 出现 10 次，1 出现 10 次，2 出现 7 次，3 出现 3 次等等…
> 
> 输入格式
> 输入包含多组测试数据。
> 
> 每组测试数据占一行，包含两个整数 a 和 b。
> 
> 当读入一行为 0 0 时，表示输入终止，且该行不作处理。
> 
> 输出格式
> 每组数据输出一个结果，每个结果占一行。
> 
> 每个结果包含十个用空格隔开的数字，第一个数字表示 0 出现的次数，第二个数字表示 1 出现的次数，以此类推。
> 
> 数据范围  
> 0<a,b<100000000
> 
> 输入样例  
>> 1 10
>> 44 497
>> 346 542
>> 1199 1748
>> 1496 1403
>> 1004 503
>> 1714 190
>> 1317 854
>> 1976 494
>> 1001 1960
>> 0 0
> 
> 输出样例  
>>1 2 1 1 1 1 1 1 1 1
>>85 185 185 185 190 96 96 96 95 93
>>40 40 40 93 136 82 40 40 40 40
>>115 666 215 215 214 205 205 154 105 106
>>16 113 19 20 114 20 20 19 19 16
>>107 105 100 101 101 197 200 200 200 200
>>413 1133 503 503 503 502 502 417 402 412
>>196 512 186 104 87 93 97 97 142 196
>>398 1375 398 398 405 499 499 495 488 471
>>294 1256 296 296 296 296 287 286 286 247>

## 题目分析

本题是求**两个整数之间，所有数中，数字0~9的出现次数**。

例如：求`5~13`中`0~9`出现的次数。

先看`5~13`中的数包含`[5,6,7,8,9,10,11,12,13]`。
其中`0`出现`1`次，在数字`[10]`中；
其中`1`出现`5`次，在数字`[10,11,12,13]`中，`11`算`1`出现两次；
其中`4`出现`0`次；
而其余数字`[2,3,5,6,7,8,9]`皆出现`1`次；

**本题最重要的一点就是分情况讨论**

我们想要知道`a~b`之间每个数字的次数，那么我们可以用如下思想分步求解。

**用f(n, x)表示状态在1~n中数字x出现的次数**。

那么我们很容易就可以想到：

`f(b, x)`表示`1~b中x的出现次数`；

`f(a - 1, x)`表示`1~a-1中x出现的次数`；
**用f(b, x)-f(a - 1, x)，就能计算出a~b中x出现的次数**。

此时，问题转移为：**求出1~n中x出现的次数**。

为了使上述问题可以满足题目的答案，`x`的取值必须是`0~9`，进一步的，我们可以发现`x`无论取任何值都可以使用一种相同方式来解决，即**分别求出x在每一位出现的次数**。

假设，此时的所求范围是`1~abcdefg`，我们想求`x`在第四位上出现的次数。那么目前知道了第四位出现的数字是`x`，其他位置上的数字一概不知，所以我们以第四位数字x为界限，假设现在数字是`qqqxyyy`。于是，就有了公式`1 <= xxx1yyy <= abcdefg`，我们可以分如下情况讨论所有可能：

当`000 <= qqq <= abc-1`的时候，因为当前值前三位`qqq`已经小于最大值前三位`abc`，所以`efg`的取值可以在范围`000~999`中任意取，此情况，可以提供`abc*1000`个`x`。

当`qqq == abc`的时候：
1. 当`d < x`的时候，无论`efg`如何取值，都一定有`xyyy > defg`，因此，当前数字超出最大值范围，该情况无法提供`x`。
2. 当`d == x`的时候，有等式`qqqx == abcd`，那么留给`efg`的取值范围就剩下了`000~efg`，所以，该情况提供`efg + 1`个`x`。
3. 当`d > x`的时候，一定有范围`qqqx < abcd`，所以`efg`的取值可以在`000~999`之间任意取，该情况提供`1000`个`x`。
4. 特殊情况，当`x`的取值为`0`的时候，`qqq`不能取到`000`。因为当`x`的取值为`0`时，如果`qqq`取`000`，整个数字就变成了`0000yyy`，注意这不是一个合法的表示，会错误计算`0`出现的次数。因此，这时必须从`001`开始枚举，也就是说当`x==0`时候，第一种情况提供的`x`个数为`（abc-1）*1000`。

## Code
;;;id1 CPP
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

/* 
  求出n的l到r位，如:abcdefg 当l=6，r=4时，返回abc
*/
int get(vector<int> nums, int l, int r) {
    int res = 0;
    for (int i = l; i >= r; i -- ){
        res = res * 10 + nums[i];
    }
    return res;
}

int power10(int x) {
    int res = 1;
    while (x -- ) res *= 10;
    return res;
}

/* 状态f(n, x) */
int count(int n, int x) {
    
    if (!n) return 0;
    vector<int> nums;
    // 取出n中的每一位
    while (n) {
        nums.push_back(n % 10);
        n /= 10;
    }
    n = nums.size(); //n的位数
    int res = 0;
    // 枚举每一位 其中 !x 表示当x等于0从第二位开始枚举（因为最高位不能取0）
    for (int i = n - 1 - !x; i >= 0; i -- ) {
        // 当i是(abcdefg)中的第一位a的时候，第一种情况是不存在的
        // （因为前缀abc的取值是0~-1）所以情况1从第二个数开始。
        if (i < n - 1) {
            // 情况1，如：abcdefg 先求出abc 再乘 10^3(这里的3就是下标i)
            res += get(nums, n - 1, i + 1) * power10(i);
            // 情况3 特殊情况 当x == 0时候 少枚举一次 10^i 。
            if (!x) res -= power10(i);
        }
        // 情况2.1无需处理；
        // 处理情况2.2  也就是efg的部分；
        if (nums[i] == x) res += get(nums, i - 1, 0) + 1;
        // 处理情况2.3  也就是efg取值（000~999）
        else if (nums[i] > x) res += power10(i);
    }
    return res;
}

int main() {
    int a, b;
    while (cin >> a >> b, a || b) {
        if (a > b) swap(a, b);
        for (int i = 0; i < 10; i ++ )
            cout << count(b, i) - count(a - 1, i) << ' ';
        cout << endl;
    }
    return 0;
}
```
;;;

;;;id1 Python
```python
def get(nums, l, r):
    res = 0
    for i in range(l, r - 1, -1):
        res = res * 10 + nums[i]
    return res

def count(n, x):
    if not n:
        return 0
    nums = []
    while n:
        nums.append(n % 10)
        n = int(n / 10)
    n = len(nums)
    res = 0
    for i in range(n - 1 - (not x), -1, -1):
        # print(i)
        if i < n - 1:
            res += get(nums, n - 1, i + 1) * (10 ** i)
            if not x:
                res -= (10 ** i)
        if nums[i] == x:
            res += get(nums, i - 1, 0) + 1
        elif nums[i] > x:
            res += (10 ** i)
    return res

while 1:
    res = []
    a, b = list(map(int, input().split()))    
    if a == b == 0:
        break
    if a > b: a, b = b, a
    for i in range(10):
        res.append(str(count(b, i) - count(a - 1, i)))
    print(' '.join(res))
```
;;;

